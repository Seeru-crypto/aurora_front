import Head from "next/head";
import { useEffect, useRef } from "react";
import styled from "styled-components";
import Contact from "../components/contact/Contact";
import Experience from "../components/experience/Experience";
import LandingPage from "../components/landing/LandingPage";
import { Toast } from "../components/util";
import { formatDate } from "../components/work/Card";
import Work, { WorkProps } from "../components/work/Work";
import config from "../config.json";
import {
  loadLocalData,
  mergeGitProjectData,
  ProjectInterface,
  TimelineCard,
} from "../lib/load-data";
import {
  changeToastValue,
  setAuroraLastUpdated,
  setCurrentPage,
  setNumberOfProjects,
} from "../state/appSlice";
import { RootState, useAppDispatch, useAppSelector } from "../state/store";

export default function Home({
  projects,
  techTypes,
  timeLineCards,
}: {
  projects: ProjectInterface[];
  timeLineCards: TimelineCard[];
  techTypes: Iterable<readonly [string, string]>;
}) {
  const workProps: WorkProps = {
    projects,
    techTypes: new Map<string, string>(techTypes),
  };

  const isToastShown: boolean = useAppSelector(
    (state: RootState) => state.app.isToastShown
  );
  const dispatch = useAppDispatch();

  useEffect(() => {
    if (isToastShown) {
      setTimeout(() => {
        dispatch(changeToastValue());
      }, 3000);
    }
  }, [isToastShown, dispatch]);

  useEffect(() => {
    dispatch(setNumberOfProjects(projects.length));
    // Spike can this loop be transformed into a server side function?
    projects.forEach((project) => {
      if (project.project_name === "Aurora" && project.updatedAt)
        dispatch(setAuroraLastUpdated(formatDate(project.updatedAt, false)));
    });
  }, [projects, dispatch]);

  const experienceRef = useRef<HTMLDivElement>(null);
  const contactRef = useRef<HTMLDivElement>(null);
  const landingRef = useRef<HTMLDivElement>(null);
  const projectRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const intersectionCallback = (entries: IntersectionObserverEntry[]) => {
      entries.forEach((entry: IntersectionObserverEntry) => {
        if (entry.isIntersecting) {
          dispatch(setCurrentPage(entry.target.id));
        }
      });
    };

    const intersectionOptions = {
      root: null,
      rootMargin: "0px",
      threshold: 0.8,
    };

    const observer = new IntersectionObserver(
      intersectionCallback,
      intersectionOptions
    );

    if (landingRef.current) observer.observe(landingRef.current);
    if (experienceRef.current) observer.observe(experienceRef.current);
    if (projectRef.current) observer.observe(projectRef.current);
    if (contactRef.current) observer.observe(contactRef.current);

    return () => {
      // ToDo fix potential error, where ref is already changed by the time this function runs
      if (landingRef.current) observer.unobserve(landingRef.current);
      if (experienceRef.current) observer.unobserve(experienceRef.current);
      if (projectRef.current) observer.unobserve(projectRef.current);
      if (contactRef.current) observer.unobserve(contactRef.current);
    };
  }, [experienceRef, projectRef, landingRef, contactRef, dispatch]);

  return (
    <IndexStyle>
      <Head>
        <title>Aurora </title>
        <meta
          name="description"
          content="Generated by create next app, made by FO"
        />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="main">
        {isToastShown && <Toast message="Added to clipboard" />}
        <LandingPage ref={landingRef} />
        <Experience timeLineCards={timeLineCards} ref={experienceRef} />
        <Work workProps={workProps} ref={projectRef} />
        <Contact ref={contactRef} />
      </main>
    </IndexStyle>
  );
}

export async function getStaticProps() {
  console.log("current url: ", process.env.GIT_REPO_DATA_URL);
  const localJsonData = await loadLocalData();
  const projects = await mergeGitProjectData(
    localJsonData.projects,
    process.env.GIT_REPO_DATA_URL,
    process.env.GITHUB_TOKEN
  );
  const techTypeList: string[][] = config.TECH_TYPES;
  const timeLineCards: TimelineCard[] = localJsonData.experience;

  return {
    props: {
      projects: projects,
      techTypes: techTypeList,
      timeLineCards: timeLineCards,
    },
    revalidate: process.env.REVALIDATE_VALUE,
  };
}

const IndexStyle = styled.div`
  padding: 0 2rem;

  .main {
    min-height: 50vh;
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
`;
